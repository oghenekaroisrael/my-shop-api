// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: inventory.sql

package db

import (
	"context"
)

const createItem = `-- name: CreateItem :one
INSERT INTO inventories (
  item_name,
  quantity,
  cost_price,
  selling_price_standard,
  status,
  shop_id
) VALUES (
  $1, $2, $3,$4, $5, $6
)
RETURNING id, item_name, quantity, cost_price, selling_price_standard, status, shop_id, created_at
`

type CreateItemParams struct {
	ItemName             string `json:"item_name"`
	Quantity             int32  `json:"quantity"`
	CostPrice            int32  `json:"cost_price"`
	SellingPriceStandard int32  `json:"selling_price_standard"`
	Status               string `json:"status"`
	ShopID               int32  `json:"shop_id"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.ItemName,
		arg.Quantity,
		arg.CostPrice,
		arg.SellingPriceStandard,
		arg.Status,
		arg.ShopID,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ItemName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPriceStandard,
		&i.Status,
		&i.ShopID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteItem = `-- name: DeleteItem :exec
DELETE FROM inventories
WHERE id = $1
`

func (q *Queries) DeleteItem(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteItem, id)
	return err
}

const getItemById = `-- name: GetItemById :one
SELECT id, item_name, quantity, cost_price, selling_price_standard, status, shop_id, created_at FROM inventories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetItemById(ctx context.Context, id int32) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getItemById, id)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ItemName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPriceStandard,
		&i.Status,
		&i.ShopID,
		&i.CreatedAt,
	)
	return i, err
}

const listMyInventories = `-- name: ListMyInventories :many
SELECT id, item_name, quantity, cost_price, selling_price_standard, status, shop_id, created_at FROM inventories
WHERE shop_id = $1
ORDER BY id 
LIMIT $2
OFFSET $3
`

type ListMyInventoriesParams struct {
	ShopID int32 `json:"shop_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMyInventories(ctx context.Context, arg ListMyInventoriesParams) ([]Inventory, error) {
	rows, err := q.db.QueryContext(ctx, listMyInventories, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.ItemName,
			&i.Quantity,
			&i.CostPrice,
			&i.SellingPriceStandard,
			&i.Status,
			&i.ShopID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInventoryByName = `-- name: SearchInventoryByName :many
SELECT id, item_name, quantity, cost_price, selling_price_standard, status, shop_id, created_at FROM inventories
WHERE shop_id = $1 AND item_name = $2
ORDER BY id 
LIMIT $3
OFFSET $4
`

type SearchInventoryByNameParams struct {
	ShopID   int32  `json:"shop_id"`
	ItemName string `json:"item_name"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) SearchInventoryByName(ctx context.Context, arg SearchInventoryByNameParams) ([]Inventory, error) {
	rows, err := q.db.QueryContext(ctx, searchInventoryByName,
		arg.ShopID,
		arg.ItemName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.ItemName,
			&i.Quantity,
			&i.CostPrice,
			&i.SellingPriceStandard,
			&i.Status,
			&i.ShopID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateItemDetail = `-- name: UpdateItemDetail :one
UPDATE inventories
set 
    item_name = $2,
    cost_price = $3,
    selling_price_standard = $4,
    status = $5
WHERE id = $1
RETURNING id, item_name, quantity, cost_price, selling_price_standard, status, shop_id, created_at
`

type UpdateItemDetailParams struct {
	ID                   int32  `json:"id"`
	ItemName             string `json:"item_name"`
	CostPrice            int32  `json:"cost_price"`
	SellingPriceStandard int32  `json:"selling_price_standard"`
	Status               string `json:"status"`
}

func (q *Queries) UpdateItemDetail(ctx context.Context, arg UpdateItemDetailParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, updateItemDetail,
		arg.ID,
		arg.ItemName,
		arg.CostPrice,
		arg.SellingPriceStandard,
		arg.Status,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ItemName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPriceStandard,
		&i.Status,
		&i.ShopID,
		&i.CreatedAt,
	)
	return i, err
}

const updateItemQuantity = `-- name: UpdateItemQuantity :one
UPDATE inventories
set 
    quantity = $2
WHERE id = $1
RETURNING id, item_name, quantity, cost_price, selling_price_standard, status, shop_id, created_at
`

type UpdateItemQuantityParams struct {
	ID       int32 `json:"id"`
	Quantity int32 `json:"quantity"`
}

func (q *Queries) UpdateItemQuantity(ctx context.Context, arg UpdateItemQuantityParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, updateItemQuantity, arg.ID, arg.Quantity)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ItemName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPriceStandard,
		&i.Status,
		&i.ShopID,
		&i.CreatedAt,
	)
	return i, err
}
