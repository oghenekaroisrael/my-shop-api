// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: sale.sql

package db

import (
	"context"
	"time"
)

const createSale = `-- name: CreateSale :one
INSERT INTO sales (
  item_id,
  quantity,
  selling_price_actual,
  payment_type,
  shop_id
) VALUES (
  $1, $2, $3,$4, $5
)
RETURNING id, item_id, quantity, selling_price_actual, payment_type, shop_id, created_at
`

type CreateSaleParams struct {
	ItemID             int32  `json:"item_id"`
	Quantity           int32  `json:"quantity"`
	SellingPriceActual int32  `json:"selling_price_actual"`
	PaymentType        string `json:"payment_type"`
	ShopID             int32  `json:"shop_id"`
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (Sale, error) {
	row := q.db.QueryRowContext(ctx, createSale,
		arg.ItemID,
		arg.Quantity,
		arg.SellingPriceActual,
		arg.PaymentType,
		arg.ShopID,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Quantity,
		&i.SellingPriceActual,
		&i.PaymentType,
		&i.ShopID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE FROM sales
WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSale, id)
	return err
}

const getSaleById = `-- name: GetSaleById :one
SELECT id, item_id, quantity, selling_price_actual, payment_type, shop_id, created_at FROM sales
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSaleById(ctx context.Context, id int32) (Sale, error) {
	row := q.db.QueryRowContext(ctx, getSaleById, id)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Quantity,
		&i.SellingPriceActual,
		&i.PaymentType,
		&i.ShopID,
		&i.CreatedAt,
	)
	return i, err
}

const listMySales = `-- name: ListMySales :many
SELECT id, item_id, quantity, selling_price_actual, payment_type, shop_id, created_at FROM sales
WHERE shop_id = $1
ORDER BY id 
LIMIT $2
OFFSET $3
`

type ListMySalesParams struct {
	ShopID int32 `json:"shop_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMySales(ctx context.Context, arg ListMySalesParams) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, listMySales, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sale{}
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Quantity,
			&i.SellingPriceActual,
			&i.PaymentType,
			&i.ShopID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalesByUser = `-- name: ListSalesByUser :many
SELECT 
sale.id AS id, 
inventories.item_name AS item_name,
sale.item_id AS item_id, 
sale.quantity AS quantity, 
sale.selling_price_actual AS selling_price,
sale.payment_type AS payment_type,
sale.created_at AS created_at
FROM sales sale
INNER JOIN shops ON sale.shop_id = shops.id
INNER JOIN users ON shops.user_id = users.id
INNER JOIN inventories ON sale.item_id = inventories.id
WHERE users.id = $1
ORDER BY sale.created_at DESC
LIMIT $2
OFFSET $3
`

type ListSalesByUserParams struct {
	ID     int32 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSalesByUserRow struct {
	ID           int32     `json:"id"`
	ItemName     string    `json:"item_name"`
	ItemID       int32     `json:"item_id"`
	Quantity     int32     `json:"quantity"`
	SellingPrice int32     `json:"selling_price"`
	PaymentType  string    `json:"payment_type"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) ListSalesByUser(ctx context.Context, arg ListSalesByUserParams) ([]ListSalesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listSalesByUser, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSalesByUserRow{}
	for rows.Next() {
		var i ListSalesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemName,
			&i.ItemID,
			&i.Quantity,
			&i.SellingPrice,
			&i.PaymentType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSaleBetweenDates = `-- name: SearchSaleBetweenDates :many
SELECT id, item_id, quantity, selling_price_actual, payment_type, shop_id, created_at FROM sales
WHERE shop_id = $1 AND created_at BETWEEN $2 AND $2
ORDER BY id 
LIMIT $3
OFFSET $4
`

type SearchSaleBetweenDatesParams struct {
	ShopID    int32     `json:"shop_id"`
	CreatedAt time.Time `json:"created_at"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) SearchSaleBetweenDates(ctx context.Context, arg SearchSaleBetweenDatesParams) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, searchSaleBetweenDates,
		arg.ShopID,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sale{}
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Quantity,
			&i.SellingPriceActual,
			&i.PaymentType,
			&i.ShopID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
